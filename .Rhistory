setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
set.seed(3101990)
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
library("xtable")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/OBest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
source("simulations/MCXP_setup.R")
data = read.table("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta",
header=TRUE, skip=3)
library("foreign")
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
head(data)
d = data["state",]==1
d
data["state",]
data[,"state"]
d = data[,"state"]==1
sum(d)
data[,"chain"]
head(data)
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
data[,"BK"] = data[,"chain"] == 1
data[,"KFC"] = data[,"chain"] == 2
data[,"RR"] = data[,"chain"] == 3
d = data[,"state"]==1
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
head(X)
sum(is.na(X))
X[,"co_owned"]
X[,"empft"]
X[,"emppt"]
complete.cases(X)
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
X = X[complete.cases(X),]
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
data[,"BK"] = data[,"chain"] == 1
data[,"KFC"] = data[,"chain"] == 2
data[,"RR"] = data[,"chain"] == 3
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
d = data[complete.cases(X),"state"]==1
X = X[complete.cases(X),]
### Use penalized synthetic control
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
y = data[,"empft2"]
complete.cases(data)
sum(complete.cases(data))
### Load data
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
data[,"BK"] = data[,"chain"] == 1
data[,"KFC"] = data[,"chain"] == 2
data[,"RR"] = data[,"chain"] == 3
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
y = data[,"empft2"]
uu = complete.cases(cbind(X,y))
d = data[uu,"state"]==1
X = X[uu,]
y = y[uu]
### Use penalized synthetic control
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
sol = regsynth(X0,X1,Y0,Y1,V,.1)
RSC.fixed = sol$ATT
RSC.fixed
# B. lambda = lambdaopt
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
lambda = seq(0,2,.01) # set of lambda to be considered for optim
K = 5 # number of folds for optimal penalty level
# B. lambda = lambdaopt
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
lambda = seq(0,2,.01) # set of lambda to be considered for optim
K = 5 # number of folds for optimal penalty level
# B. lambda = lambdaopt
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
lambda = seq(0,2,.01) # set of lambda to be considered for optim
K = 5 # number of folds for optimal penalty level
### Splitting the sample for cross-validation
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
# B. lambda = lambdaopt
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
# The one that optimizes RMSE
curve.RMSE = apply(keeptau^2,1,sum)/n0
lambda.opt.RMSE = min(lambda[which(curve.RMSE==min(curve.RMSE))])
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.RMSE)
RSC.opt.RMSE = sol$ATT
# The one that optimizes bias
curve.bias = abs(apply(keeptau,1,sum)/n0)
lambda.opt.bias = min(lambda[which(curve.bias==min(curve.bias))])
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.bias)
RSC.opt.bias = sol$ATT
# The one that optimizes bias + variance
curve.crit = curve.bias + apply(keeptau,1,sd)
lambda.opt.crit = min(lambda[which(curve.crit==min(curve.crit))])
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.crit)
RSC.opt.crit = sol$ATT
RSC.opt.RMSE
RSC.opt.bias
RSC.opt.crit
plot(lambda,curve.RMSE)
lambda.opt.RMSE
plot(lambda,curve.bias)
RSC.fixed
sol$w
y = data[,"empft2"]
d = data[uu,"state"]==1
mean(y[d==1])-mean(y[d==0])
mean(y[d==1],na.rm=T)-mean(y[d==0])
mean(y[d==1],na.rm=T)-mean(y[d==0,na.rm=T])
mean(y[d==1],na.rm=T)-mean(y[d==0,na.rm=T)
mean(y[d==1],na.rm=T)-mean(y[d==0],na.rm=T)
mean(y[d==1],na.rm=T)
y[d==1]
y
d
mean(y[d],na.rm=T)-mean(y[!d],na.rm=T)
y[d]
d
d = data[uu,"state"]==1
d
d = data[,"state"]==1
d
mean(y[d],na.rm=T)-mean(y[!d],na.rm=T)
mean(data[d,"empft2"],na.rm=T)-mean(y[!d],na.rm=T)
mean(data[d,"empft2"],na.rm=T)-mean(ydata[!d,"empft2"],na.rm=T)
mean(data[d,"empft2"],na.rm=T)-mean(data[!d,"empft2"],na.rm=T)
mean(data[d,"empft2"],na.rm=T)-mean(data[!d,"empft2"],na.rm=T) - (mean(data[d,"empft"],na.rm=T)-mean(data[!d,"empft"],na.rm=T))
### Load data
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
data[,"BK"] = data[,"chain"] == 1
data[,"KFC"] = data[,"chain"] == 2
data[,"RR"] = data[,"chain"] == 3
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
y = data[,"empft2"]
sum(data[,"state"]==1)
apply(X1,1,mean)
X0%*%sol$Wsol
X0%*%t(sol$Wsol)
X1 - X0%*%t(sol$Wsol)
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
# A. lambda = .1
sol = regsynth(X0,X1,Y0,Y1,V,0)
RSC.fixed = sol$ATT
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
# A. lambda = .1
sol = regsynth(X0,X1,Y0,Y1,V,10)
RSC.fixed = sol$ATT
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
sol$ATT
# A. lambda = .1
sol = regsynth(X0,X1,Y0,Y1,V,.1)
RSC.fixed = sol$ATT
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
# A. lambda = .1
sol = regsynth(X0,X1,Y0,Y1,V,.1)
RSC.fixed = sol$ATT
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
RSC.fixed
V[5,5] = 100
V
### Load data
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
data[,"BK"] = data[,"chain"] == 1
data[,"KFC"] = data[,"chain"] == 2
data[,"RR"] = data[,"chain"] == 3
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
y = data[,"empft2"]
uu = complete.cases(cbind(X,y))
d = data[uu,"state"]==1
X = X[uu,]
y = y[uu]
### Use penalized synthetic control
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
# A. lambda = .1
V[5,5] = 100
sol = regsynth(X0,X1,Y0,Y1,V,.1)
RSC.fixed = sol$ATT
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
sol$ATT
apply(sol$Wsol,1,mean)
apply(sol$Wsol,2,mean)
summarize(apply(sol$Wsol,2,mean))
summary(apply(sol$Wsol,2,mean))
hist(apply(sol$Wsol,2,mean))
c(RSC.fixed,RSC.opt.RMSE,RSC.opt.bias,RSC.opt.crit)
setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
set.seed(3101990)
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
library("xtable")
library("foreign")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/OBest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
source("simulations/MCXP_setup.R")
### Load data
data = read.dta("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth/data/fastfood.dta")
data[,"BK"] = data[,"chain"] == 1
data[,"KFC"] = data[,"chain"] == 2
data[,"RR"] = data[,"chain"] == 3
X = data[,c("BK","KFC","RR","co_owned",
"empft","emppt","nmgrs","inctime")]
y = data[,"empft2"]
uu = complete.cases(cbind(X,y))
d = data[uu,"state"]==1
X = X[uu,]
y = y[uu]
### Use penalized synthetic control
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
# A. lambda = .1
V[5,5] = 100
sol = regsynth(X0,X1,Y0,Y1,V,.1)
RSC.fixed = sol$ATT
apply(X1 - X0%*%t(sol$Wsol) ,1,mean)
lambda = seq(0,2,.01) # set of lambda to be considered for optim
K = 5 # number of folds for optimal penalty level
### Splitting the sample for cross-validation
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
# B. lambda = lambdaopt
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
# The one that optimizes RMSE
curve.RMSE = apply(keeptau^2,1,sum)/n0
lambda.opt.RMSE = min(lambda[which(curve.RMSE==min(curve.RMSE))])
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.RMSE)
RSC.opt.RMSE = sol$ATT
# The one that optimizes bias
curve.bias = abs(apply(keeptau,1,sum)/n0)
lambda.opt.bias = min(lambda[which(curve.bias==min(curve.bias))])
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.bias)
RSC.opt.bias = sol$ATT
# The one that optimizes bias + variance
curve.crit = curve.bias + apply(keeptau,1,sd)
lambda.opt.crit = min(lambda[which(curve.crit==min(curve.crit))])
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.crit)
RSC.opt.crit = sol$ATT
c(RSC.fixed,RSC.opt.RMSE,RSC.opt.bias,RSC.opt.crit)
