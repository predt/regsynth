StatDisplay[1:7,"ShapiroTest"]  <- apply(Results,2, function(x) shapiro.test(x)$p.value)
row.names(StatDisplay) <- c("Aggregate Synth","1NN Matching","5NN Matching","Penalized Synth fixed",
"Penalized Synth RMSE opt","Penalized Synth bias opt","Penalized Synth crit opt")
print(StatDisplay)
library(xtable)
xtable(StatDisplay)
sink()
close(f)
f = file()
sink(file=f)
sink()
close(f)
xtable(StatDisplay)
print(StatDisplay)
### MC XP
set.seed(12071990)
lambda = seq(0,2,.01)
K = 5 # number of folds for optimal penalty level
R = 1000
Results <- matrix(ncol=7, nrow=R)
t_start <- Sys.time()
pb <- txtProgressBar(style = 3)
for(r in 1:R){
### 0. Generate data
data = matchDGP(n=100,p=2,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
### 1. Synthetic Control on mean of treated
M = matrix(apply(X1,1,mean), ncol=1)
AggSC = wATT(y,d,wsol(X0,M,V))
### 2. 1NN matching
NN1 = matchest(d,X,y,V,1)
### 3. 5NN matching
NN5 = matchest(d,X,y,V,5)
### 4. Regularized Synthetic Control, fixed lambda
sol = regsynth(X0,X1,Y0,Y1,V,.1)
RSC.fixed = sol$ATT
### 5. Regularized SC, optimized lambda
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
print("*** PROGRESS ***")
print(100*r/R)
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
# The one that optimizes RMSE
curve.RMSE = apply(keeptau^2,1,sum)/n0
lambda.opt.RMSE = lambda[which(curve.RMSE==min(curve.RMSE))]
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.RMSE)
RSC.opt.RMSE = sol$ATT
# The one that optimizes bias
curve.bias = abs(apply(keeptau,1,sum)/n0)
lambda.opt.bias = lambda[which(curve.bias==min(curve.bias))]
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.bias)
RSC.opt.bias = sol$ATT
# The one that optimizes bias + variance
curve.crit = curve.bias + apply(keeptau,1,sd)
lambda.opt.crit = lambda[which(curve.crit==min(curve.crit))]
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.crit)
RSC.opt.crit = sol$ATT
### 6. Third step: ATT estimation
Results[r,] <- c(AggSC,NN1$ATT,NN5$ATT,
RSC.fixed,RSC.opt.RMSE,RSC.opt.bias,RSC.opt.crit)
setTxtProgressBar(pb, r/R)
}
setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
### 0. Settings
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=100,p=5,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
### 0. Settings
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=100,p=5,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
lambda = seq(0,2,.01)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
keeptau
sink()
close(f)
f = file()
sink(file=f)
sink()
close(f)
keeptau
### Penalized Synthetic Control
### Inference and permutation tests
### Jeremy L Hour
### 8 septembre 2016
setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
### 0. Settings
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=100,p=5,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
### 1. Selection of the penalty level
lambda = seq(0,2,.01)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
curve.RMSE = apply(keeptau^2,1,sum)/n0
lambda.opt.RMSE = lambda[which(curve.RMSE==min(curve.RMSE))]
sol = regsynth(X0,X1,Y0,Y1,V,lambda.opt.RMSE)
RSC.opt.RMSE = sol$ATT
# The one that optimizes RMSE
curve.RMSE = apply(keeptau^2,1,sum)/n0
lambda.opt.RMSE = lambda[which(curve.RMSE==min(curve.RMSE))]
plot(lambda,curve.RMSE)
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,lambda.opt.RMSE)
CATE0 = vector(length=n0)
for(i in 1:n0){
X0i = as.matrix(X0[,i],ncol=1)
X0_i = X0[,-i]
Y0i = Y0[i]
Y0_i = Y0[-i]
sol0 = regsynth(X0_i,X0i,Y0_i,Y0i,V,lambda.opt)
CATE0[i] = sol0$CATT
}
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,lambda.opt.RMSE)
CATE0 = vector(length=n0)
for(i in 1:n0){
X0i = as.matrix(X0[,i],ncol=1)
X0_i = X0[,-i]
Y0i = Y0[i]
Y0_i = Y0[-i]
sol0 = regsynth(X0_i,X0i,Y0_i,Y0i,V,lambda.opt.RMSE)
CATE0[i] = sol0$CATT
}
tau = data.frame(CATT=c(sol1$CATT,CATE0),
d=c(rep(1,sum(d)),rep(0,sum(1-d))))
ggplot(tau, aes(x=CATT, fill=as.factor(d))) +
geom_density(alpha=.3, position='identity', aes(y = ..density..)) +
scale_x_continuous(name="CATE") +
ggtitle("CATE DIstribution for Treated / Control group") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
scale_fill_discrete(name="Group",
breaks=c("1", "0"),
labels=c("Treated","Control")) +
theme(legend.position="bottom")
tapply(tau$CATT,tau$d)
mean(tau$CATT)
close(f)
sink()
mean(tau$CATT)
tapply(tau$CATT,tau$d)
tapply(tau$d,tau$CATT)
?tapply
tapply(tau$CATT,as.factor(tau$d))
tapply(tau$CATT,as.factor(tau$d),mean)
tapply(tau$CATT,as.factor(tau$d),sd)
ggplot(tau, aes(x=CATT, fill=as.factor(d))) +
geom_density(alpha=.3, position='identity', aes(y = ..density..)) +
scale_x_continuous(name="CATE") +
ggtitle("CATE DIstribution for Treated / Control group") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
scale_fill_discrete(name="Group",
breaks=c("1", "0"),
labels=c("Treated","Control")) +
theme(legend.position="bottom")
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=1000,p=5,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
### 1. Selection of the penalty level
lambda = seq(0,2,.01)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=1000,p=50,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
### 1. Selection of the penalty level
lambda = seq(0,2,.01)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
sink()
aa=3
aa
close(f)
aa
sink()
qq
aa
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=1000,p=50,Ry=.5,Rd=.2)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
### 1. Selection of the penalty level
lambda = seq(0,2,.01)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
curve.RMSE = apply(keeptau^2,1,sum, na.rm=T)/n0
lambda.opt.RMSE = lambda[which(curve.RMSE==min(curve.RMSE))]
plot(lambda,curve.RMSE)
lambda
close(f)
sink()
lambda.opt.RMSE
lambda.opt.RMSE=.1
### 2. Inference based on Permutation Tests
# Only controls should be used for the controls
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,lambda.opt.RMSE)
CATE0 = vector(length=n0)
for(i in 1:n0){
X0i = as.matrix(X0[,i],ncol=1)
X0_i = X0[,-i]
Y0i = Y0[i]
Y0_i = Y0[-i]
sol0 = regsynth(X0_i,X0i,Y0_i,Y0i,V,lambda.opt.RMSE)
CATE0[i] = sol0$CATT
}
tau = data.frame(CATT=c(sol1$CATT,CATE0),
d=c(rep(1,sum(d)),rep(0,sum(1-d))))
tau
ggplot(tau, aes(x=CATT, fill=as.factor(d))) +
geom_density(alpha=.3, position='identity', aes(y = ..density..)) +
scale_x_continuous(name="CATE") +
ggtitle("CATE DIstribution for Treated / Control group") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
scale_fill_discrete(name="Group",
breaks=c("1", "0"),
labels=c("Treated","Control")) +
theme(legend.position="bottom")
### Penalized Synthetic Control
### Inference and permutation tests
### Jeremy L Hour
### 8 septembre 2016
setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
### 0. Settings
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
### MC XP
set.seed(12071990)
### 0. Generate data
data = matchDGP(n=100,p=10,Ry=.5,Rd=.2,a=1)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
### 1. Selection of the penalty level
lambda = seq(0,2,.01)
K=5
uu=0 # reshuffle groups until no empty group
while(uu==0){
allocation = sample(1:K,n0,replace=T)
uu=min(mapply(function(x) sum(allocation==x),1:K))
}
keeptau = matrix(nrow=length(lambda), ncol=length(Y0))
for(k in 1:K){
X1k = as.matrix(X0[,allocation==k])
X0k = as.matrix(X0[,allocation!=k])
Y1k = Y0[allocation==k]
Y0k = Y0[allocation!=k]
solpath = regsynthpath(X0k,X1k,Y0k,Y1k,V,lambda)
keeptau[,allocation==k] = solpath$CATT
}
# The one that optimizes RMSE
curve.RMSE = apply(keeptau^2,1,sum, na.rm=T)/n0
lambda.opt.RMSE = lambda[which(curve.RMSE==min(curve.RMSE))]
plot(lambda,curve.RMSE)
lambda.opt.RMSE
### 2. Inference based on Permutation Tests
# Only controls should be used for the controls
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,lambda.opt.RMSE)
CATE0 = vector(length=n0)
for(i in 1:n0){
X0i = as.matrix(X0[,i],ncol=1)
X0_i = X0[,-i]
Y0i = Y0[i]
Y0_i = Y0[-i]
sol0 = regsynth(X0_i,X0i,Y0_i,Y0i,V,lambda.opt.RMSE)
CATE0[i] = sol0$CATT
}
tau = data.frame(CATT=c(sol1$CATT,CATE0),
d=c(rep(1,sum(d)),rep(0,sum(1-d))))
ggplot(tau, aes(x=CATT, fill=as.factor(d))) +
geom_density(alpha=.3, position='identity', aes(y = ..density..)) +
scale_x_continuous(name="CATE") +
ggtitle("CATE DIstribution for Treated / Control group") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
scale_fill_discrete(name="Group",
breaks=c("1", "0"),
labels=c("Treated","Control")) +
theme(legend.position="bottom")
tapply(tau$CATT,tau$d,mean)
lambda.opt.RMSE=.3
plot(lambda,curve.RMSE)
### 2. Inference based on Permutation Tests
# Only controls should be used for the controls
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,lambda.opt.RMSE)
CATE0 = vector(length=n0)
for(i in 1:n0){
X0i = as.matrix(X0[,i],ncol=1)
X0_i = X0[,-i]
Y0i = Y0[i]
Y0_i = Y0[-i]
sol0 = regsynth(X0_i,X0i,Y0_i,Y0i,V,lambda.opt.RMSE)
CATE0[i] = sol0$CATT
}
tau = data.frame(CATT=c(sol1$CATT,CATE0),
d=c(rep(1,sum(d)),rep(0,sum(1-d))))
ggplot(tau, aes(x=CATT, fill=as.factor(d))) +
geom_density(alpha=.3, position='identity', aes(y = ..density..)) +
scale_x_continuous(name="CATE") +
ggtitle("CATE DIstribution for Treated / Control group") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
scale_fill_discrete(name="Group",
breaks=c("1", "0"),
labels=c("Treated","Control")) +
theme(legend.position="bottom")
tapply(tau$CATT,tau$d,mean)
