setwd("//ulysse/users/JL.HOUR/1A_These/A. Research/RegSynthProject/regsynth")
rm(list=ls())
### 0. Settings
### Load packages
library("MASS")
library("ggplot2")
library("gtable")
library("grid")
library("reshape2")
library("LowRankQP")
### Load user functions
source("functions/wsol.R")
source("functions/wsoll1.R")
source("functions/matchDGP.R")
source("functions/wATT.R")
source("functions/matching.R")
source("functions/matchest.R")
source("functions/regsynth.R")
source("functions/regsynthpath.R")
source("functions/TZero.R")
source("functions/synthObj.R")
source("functions/perm.test.R")
source("functions/conf.interval.R")
### 0. Generate data
set.seed(12071990)
data = matchDGP(n=30,p=3,Ry=.5,Rd=.2,a=0)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,.1)
theta.obs = sol1$ATT
print(theta.obs)
# Get confidence interval
conf.interval(d,y,X,diag(ncol(X)),lambda=.1,B=1000,alpha=.05)
lambda=.1
B=1000
alpha=.05
### Auxiliary function
# compute.pval returns the value of the test statistics for each
# permutations of treatment assignment
compute.pval<- function(y,d,dpermut,Wsol,C,theta.obs){
Ypot0 = y - d*C; Ypot1 = y + (1-d)*C;
theta.reshuffled = mapply(function(r) mean(Ypot1[dpermut[,r]==1] - Wsol[r,,] %*% Ypot0[dpermut[,r]==0]), 1:ncol(dpermut))
p.val = mean(abs(theta.reshuffled - C) >= abs(theta.obs-C))
return(list(p.val=p.val,
theta.reshuffled=theta.reshuffled))
}
# Compute ATET on original sample
n0 = sum(1-d); n1 = sum(d); n = n1+n0;
X0 = t(X[d==0,]); X1 = t(X[d==1,]);
Y0 = y[d==0]; Y1 = y[d==1];
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,lambda)
theta.obs = sol1$ATT
# Reshuffle B times the sample and get Wsol
dpermut = matrix(nrow=n,ncol=B)
Wsol = array(dim=c(B,n1,n0))
for(b in 1:B){
dpermut[,b] = sample(d)
X0 = t(X[dpermut[,b]==0,]); X1 = t(X[dpermut[,b]==1,]);
solstar = regsynth(X0,X1,Y0,Y1,V,lambda)
Wsol[b,,] = solstar$Wsol
}
res0 = compute.pval(y,d,dpermut,Wsol,C=theta.obs,theta.obs)
b = max(res0$theta.reshuffled); eps = .01
repeat{
res0 = compute.pval(y,d,dpermut,Wsol,C=b,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=b+eps,theta.obs)
b = b + (alpha/2 - res0$p.val)*eps/(res1$p.val-res0$p.val)
}
a = theta.obs
f_a = 1-alpha/2
repeat{
m = (a+b)/2
res = compute.pval(y,d,dpermut,Wsol,C=m,theta.obs)
f_m = res$p.val - alpha/2
if(f_m*f_a > 0){
a = m
res = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
f_a = res$p.val - alpha/2
} else {
b = m
}
if(abs(b-a) < .001) break
}
Cu = (a+b)/2
# Lower bound
res0 = compute.pval(y,d,dpermut,Wsol,C=theta.obs,theta.obs)
a = min(res0$theta.reshuffled)
repeat{
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
}
b = theta.obs
f_b = 1-alpha/2
repeat{
m = (a+b)/2
res = compute.pval(y,d,dpermut,Wsol,C=m,theta.obs)
f_m = res$p.val - alpha/2
if(f_m*f_b > 0){
b = m
res = compute.pval(y,d,dpermut,Wsol,C=b,theta.obs)
f_b = res$p.val - alpha/2
} else {
a = m
}
if(abs(b-a) < .001) break
}
Cl = (a+b)/2
# Lower bound
res0 = compute.pval(y,d,dpermut,Wsol,C=theta.obs,theta.obs)
a = min(res0$theta.reshuffled)
repeat{
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
}
res0 = compute.pval(y,d,dpermut,Wsol,C=theta.obs,theta.obs)
a = min(res0$theta.reshuffled)
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
res0$p.val
alpha/2
res0$p.val < alpha/2
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
res0$p.val < alpha/2
res1$p.val
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
res0 = compute.pval(y,d,dpermut,Wsol,C=theta.obs,theta.obs)
a = min(res0$theta.reshuffled)
repeat{
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
print(a)
}
(alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
res1$p.val
res0$p.val
res0 = compute.pval(y,d,dpermut,Wsol,C=theta.obs,theta.obs)
a = min(res0$theta.reshuffled)
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
print(a)
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
print(a)
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
if(res0$p.val < alpha/2) break
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
print(a)
res0
res0$p.val
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
res1$p.val
res0$p.val-res1$p.val
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
a = a + (alpha/2 - res0$p.val)*eps/(res0$p.val-res1$p.val)
a
res0 = compute.pval(y,d,dpermut,Wsol,C=a,theta.obs)
res0
res0$p.val
res1 = compute.pval(y,d,dpermut,Wsol,C=a-eps,theta.obs)
res1
res0$p.val-res1$p.val
conf.interval(d,y,X,diag(ncol(X)),lambda=.1,B=5000,alpha=.05)
### 0. Generate data
set.seed(12071990)
data = matchDGP(n=50,p=10,Ry=.5,Rd=.2,a=0)
X = data$X; y = data$y; d = data$d
X0 = t(X[d==0,]); X1 = t(X[d==1,]); V = diag(ncol(X))
Y0 = y[d==0]; Y1 = y[d==1]; n0 = sum(1-d)
sol1 = regsynth(X0,X1,y[d==0],y[d==1],V,.1)
theta.obs = sol1$ATT
print(theta.obs)
# Get confidence interval
conf.interval(d,y,X,diag(ncol(X)),lambda=.1,B=5000,alpha=.05)
2.04+0.34
conf.interval(d,y,X,diag(ncol(X)),lambda=.1,B=250000,alpha=.05)
